package agent

import (
	"context"

	"github.com/cloudwego/eino/components/model"
	"github.com/cloudwego/eino/components/prompt"
	"github.com/cloudwego/eino/compose"
	"github.com/cloudwego/eino/schema"

	"github.com/Wenrh2004/deep_searcher/internal/infrastructure/graph"
)

var (
	FinalAnswerPrompt = `Given the following intermediate queries and answers, generate a final answer for the main query by combining relevant information. Note that intermediate answers are generated by an LLM and may not always be accurate.

## Documents
{retrieved_documents}

## Intermediate queries and answers
{intermediate_contexts}

## Main query
{query}

Respond with an appropriate answer only, do not explain yourself or output anything else.`
	finalAnswerChatTemplate = prompt.FromMessages(schema.FString, &schema.Message{
		Role:    schema.User,
		Content: FinalAnswerPrompt,
	})
)

type ChainOfRag struct {
	compose.Runnable[*schema.Message, *schema.Message]
}

func NewChainOfRag(ctx context.Context, retriever graph.RetrieverGraph, chatModel model.ToolCallingChatModel) *ChainOfRag {
	retrieverGraph, err := retriever.GetRetrieverGraph()
	if err != nil {
		panic(err)
	}
	r := compose.NewGraph[*schema.Message, *schema.Message]()
	if err := r.AddGraphNode("retriever", retrieverGraph); err != nil {
		return nil
	}
	if err := r.AddChatTemplateNode("prompt", finalAnswerChatTemplate); err != nil {
		return nil
	}
	if err := r.AddChatModelNode("final_answer", chatModel); err != nil {
		return nil
	}

	if err := r.AddEdge(compose.START, "retriever"); err != nil {
		return nil
	}
	if err := r.AddEdge("retriever", "prompt"); err != nil {

	}
	if err := r.AddEdge("prompt", "final_answer"); err != nil {

	}
	if err := r.AddEdge("final_answer", compose.END); err != nil {
	}

	chainOfRag, err := r.Compile(ctx)
	if err != nil {
		return nil
	}
	return &ChainOfRag{
		Runnable: chainOfRag,
	}
}

func (c *ChainOfRag) Query(ctx context.Context, query *schema.Message) (*schema.StreamReader[*schema.Message], error) {
	return c.Stream(ctx, query)
}
